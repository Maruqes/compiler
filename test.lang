// helper
func test(dq a){
    printHex(a);
	return;
}

func main(){
    // ===== Baseline nested array =====
    dq arr = dq{1,2,3,dq{10,11,12,dq{0xaa, dq{0x2020, 0x2021, 0x2022, 0x23, 0x24}, 0xcc, 0xdd}}, dq{}};

    // Baseline prints (top level)
    printHex(arr[0*8]);        // expect 1
    printHex(arr[1*8]);        // expect 2
    printHex(arr[2*8]);        // expect 3
    printHex(arr[3*8]);        // ptr to nested

    // 2nd level under arr[3]
    printHex(arr[3*8][0*8]);   // 10
    printHex(arr[3*8][1*8]);   // 11
    printHex(arr[3*8][2*8]);   // 12
    printHex(arr[3*8][3*8]);   // ptr to deeper

    // 3rd level under arr[3][3]
    printHex(arr[3*8][3*8][0*8]); // 0xaa
    printHex(arr[3*8][3*8][1*8]); // ptr to dq{0x2020,...}
    printHex(arr[3*8][3*8][2*8]); // 0xcc
    printHex(arr[3*8][3*8][3*8]); // 0xdd

    // 4th level under arr[3][3][1]
    printHex(arr[3*8][3*8][1*8][0*8]); // 0x2020
    printHex(arr[3*8][3*8][1*8][1*8]); // 0x2021
    printHex(arr[3*8][3*8][1*8][2*8]); // 0x2022
    printHex(arr[3*8][3*8][1*8][3*8]); // 0x23
    printHex(arr[3*8][3*8][1*8][4*8]); // 0x24

    dd c = 0;
    while 1 == 1 {
        c = c + 1;

        dd ms = 2;

        test(0x1111111111111111);

        if c == 2 {
            dd tmp = 9;
            test(0x2222222222222222);
            continue;
        }

        if c == 4 {
            dd zap = 7;
            test(0x3333333333333333);
            break;
        }

    }

    // after while, stack must be back to pre-loop base
    dq afterWhile = 0xAAAAAAAAAAAAAAA0;
    printHex(afterWhile);     // should print exactly this value

    // Re-print a few array cells to confirm nothing got corrupted
    printHex(arr[0*8]);                    // still 1
    printHex(arr[3*8][3*8][1*8][4*8]);     // still 0x24

    // init
    
    for dq i = 0; i < 8; i = i + 1; {
        // locals inside body
        dd bodyLocal = 123;

        // call inside body (alignment check again)
        test(0x4444444444444444 + i);

        if i == 3 {
            // allocate another local + call, then continue
            dd onlyHere = 5;
            test(0x5555555555555555);
            continue;
        }
        if i == 6 {
            // break path with its own allocs + call
            dd bye = 6;
            test(0x6666666666666666);
            break;
        }

        test(arr[3*8][3*8][1*8][i]); 
    }

    // after for, stack must again be at the same base
    dq afterFor = 0xBBBBBBBBBBBBBBB0;
    printHex(afterFor);      // should match exactly

    // final sanity prints on the array
    printHex(arr[1*8]);                  // still 2
    printHex(arr[3*8][2*8]);             // still 12
    printHex(arr[3*8][3*8][3*8]);        // still 0xdd

    dq arr22 = dq{1,2,3,dq{10,11,12,dq{0xaa, dq{0x2020, 0x2021, 0x2022, 0x023}, 0xcc, 0xdd}}};

	//com dd isto da seg fault com dq funciona
	for dq u = 0; u < 3; u = u + 1; {
		printHex(arr22[u*8]);
	}


    return;
}
