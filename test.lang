
global{
}


include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")
include("liblang/net.lang")
include("liblang/file.lang")

struct Struct1{
    dq a;
    dq arr dq<2>;
    dq b;
}

struct Struct2{
    dq a;
    dq s1s Struct1<2>;
    dq b;
}


// Attempt to overflow the internal fixed-size array inside Struct1 and observe overwrite of field b
func test_struct_overwrite1(){
    print("\n-- test_struct_overwrite1 --\n");
    ptr s<Struct1> = Struct1{};
    s.a = 0x11; // 17
    s.b = 0x44; // 68
    ptr arr<dq> = &s.arr; // points to first dq inside arr
    arr[0] = 0x22; // 34
    arr[1] = 0x33; // 51
    print("before oob write\n");
    printHex(s.a);       // expect 11
    printHex(arr[0]);    // expect 22
    printHex(arr[1]);    // expect 33
    printHex(s.b);       // expect 44
    // arr has length 2; arr[2] should overwrite s.a field 
    arr[2] = 0x55; // 85
    print("after arr[2] = 0x55 (expect s.a changed)\n");
    printHex(s.a);       // expect 55 (overwritten)
    printHex(arr[0]);    // expect 22
    printHex(arr[1]);    // expect 33
    printHex(s.b);       // expect 44 
    // Further go one more -> arr[3] would target memory beyond this Struct1 instance (unsafe) but we skip here
    return;
}

// Corrupt the next Struct1 inside an array by writing arr[3] (beyond arr + b of first struct)
func test_cross_element_corruption(){
    print("\n-- test_cross_element_corruption --\n");
    ptr s2<Struct2> = Struct2{};
    s2.a = 0xAA;
    s2.b = 0xBB;
    ptr base<Struct1> = &s2.s1s; // first Struct1
    ptr second<Struct1> = &s2.s1s + sizeof(Struct1); // second Struct1 (like earlier logic)

    // init first
    base.a = 1; base.b = 4; *<dq>(&base.arr) = 2; *<dq>(&base.arr + 8) = 3;
    // init second
    second.a = 5; second.b = 8; *<dq>(&second.arr) = 6; *<dq>(&second.arr + 8) = 7;

    print("before corruption\n");
    printHex(base.a);          // 1
    printHex(*(&base.arr));    // 2
    printHex(*(&base.arr + 8));// 3
    printHex(base.b);          // 4
    printHex(second.a);        // 5
    printHex(*(&second.arr));  // 6
    printHex(*(&second.arr+8));// 7
    printHex(second.b);        // 8
    printHex(s2.a);          // AA
    printHex(s2.b);          // BB

    // Write arr[3] of first (arr[0], arr[1], b, then next struct a) -> expect second.a overwritten
    ptr arr_first<dq> = &base.arr;
    arr_first[3] = 0x99; // should target second.a

    print("after arr_first[3] = 0x99 (expect second.a changed)\n");
    printHex(base.a);          // 1
    printHex(arr_first[0]);    // 2
    printHex(arr_first[1]);    // 3
    printHex(base.b);          // 4
    printHex(second.a);        // 5
    printHex(*(&second.arr));  // 6
    printHex(*(&second.arr+8));// 7
    printHex(second.b);        // 0x99 expected
    printHex(s2.a);          // AA
    printHex(s2.b);          // BB
    return;
}

// Allocate multiple Struct1 instances and verify isolation between them when writing in-bounds
func test_multiple_instances_isolation(){
    print("\n-- test_multiple_instances_isolation --\n");
    ptr s1<Struct1> = Struct1{};
    ptr s2<Struct1> = Struct1{};
    ptr s3<Struct1> = Struct1{};

    // Patterned initialization
    s1.a=10; s1.b=13; *<dq>(&s1.arr)=11; *<dq>(&s1.arr+8)=12;
    s2.a=20; s2.b=23; *<dq>(&s2.arr)=21; *<dq>(&s2.arr+8)=22;
    s3.a=30; s3.b=33; *<dq>(&s3.arr)=31; *<dq>(&s3.arr+8)=32;

    print("initial values\n");
    printHex(s1.a); printHex(*(&s1.arr)); printHex(*(&s1.arr+8)); printHex(s1.b);
    printHex(s2.a); printHex(*(&s2.arr)); printHex(*(&s2.arr+8)); printHex(s2.b);
    printHex(s3.a); printHex(*(&s3.arr)); printHex(*(&s3.arr+8)); printHex(s3.b);

    // Modify middle instance only
    s2.a=200; *<dq>(&s2.arr)=210; *<dq>(&s2.arr+8)=220; s2.b=230;

    print("after modifying s2 only (s1 & s3 should remain same)\n");
    printHex(s1.a); printHex(*(&s1.arr)); printHex(*(&s1.arr+8)); printHex(s1.b);
    printHex(s2.a); printHex(*(&s2.arr)); printHex(*(&s2.arr+8)); printHex(s2.b);
    printHex(s3.a); printHex(*(&s3.arr)); printHex(*(&s3.arr+8)); printHex(s3.b);
    return;
}

func main() {
    ptr s<Struct1> = Struct1{};

    s.a = 1;
    s.b = 4;
    //use 1
    *<dq>(&s.arr) = 2;
    *<dq>(&s.arr + 8) = 3;

    //use 2
    ptr s_arr<dq> = &s.arr;
    s_arr[0] = 2;
    s_arr[1] = 3;


    printHex(s.a);
    printHex(*(&s.arr));
    printHex(*(&s.arr + 8));
    printHex(s.b);


    ptr s2<Struct2> = Struct2{};

    s2.a = 1;
    s2.b = 6;

    ptr s2s_arr<Struct1> = &s2.s1s;

    ptr s2s_arr_0<Struct1> = &s2s_arr;
    ptr s2s_arr_1<Struct1> = &s2s_arr + sizeof(Struct1);

    s2s_arr_0.a = 2;
    s2s_arr_0.b = 5;
    *<dq>(&s2s_arr_0.arr) = 3;
    *<dq>(&s2s_arr_0.arr + 8) = 4;

    printHex(s2s_arr_0.a);
    printHex(*(&s2s_arr_0.arr));
    printHex(*(&s2s_arr_0.arr + 8));
    printHex(s2s_arr_0.b);

    s2s_arr_1.a = 3;
    s2s_arr_1.b = 8;
    *<dq>(&s2s_arr_1.arr) = 4;
    *<dq>(&s2s_arr_1.arr + 8) = 5;

    printHex(s2s_arr_1.a);
    printHex(*(&s2s_arr_1.arr));
    printHex(*(&s2s_arr_1.arr + 8));
    printHex(s2s_arr_1.b);

    // --- Extra stress tests ---
    test_struct_overwrite1();
    test_cross_element_corruption();
    test_multiple_instances_isolation();

    printHex(sizeof(Struct1));
    printHex(sizeof(Struct2));
    printHex(sizeof(dq));
    printHex(sizeof(dd));
    printHex(sizeof(dw));
    printHex(sizeof(db));
    return;
}
