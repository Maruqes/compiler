func main() {
    ptr arr = db{1,2,3,4};
	// problema nos arrays arr[0]
	dq a = arr[0];
	printHex(a);

	
	// if (5 > 4) && (1 == 1){
	// 	printHex(0xff0000);
	// }

	// //problema em criacao de variaveis ao acabr o loop tem de voltar a stack
	

	// dq a = 0;
	// while a < 10 {
	// 	printHex(a);
	// 	a++;
	// }


	// for dq i = 0; (i < 10) && (1==1) ; i++; {

	// 	if i == 5 {
	// 		continue;
	// 	}
	// 	printHex(i);
	// }

	// for dq i = 0; (i < 10) && (1==1) ; i++; {

	// 	if i == 5 {
	// 		continue;
	// 	}
	// 	printHex(i);
	// }


	// // ----- More nested control-flow tests -----

	// // if-else ladder with inner-scope variable declarations
	// dq t = 4;
	// if t == 1 {
	// 	dq z = 0x64; // 100
	// 	printHex(z);
	// } elif t == 2 {
	// 	printHex(0x2);
	// } elif (t > 2) && (t < 5) {
	// 	dq z = 0xC8; // 200
	// 	printHex(z);
	// } else {
	// 	printHex(0x0);
	// }

	// // while-within-while; exercise continue/break and complex conditions
	// dq outer = 0;
	// while outer < 3 {
	// 	dq inner = 0;
	// 	while inner < 4 {
	// 		// skip a specific pair
	// 		if (outer == 1) && (inner == 1) {
	// 			inner++;
	// 			continue;
	// 		}
	// 		// break the inner loop on a condition
	// 		if (outer == 2) && (inner == 0) {
	// 			break;
	// 		}
	// 		printHex((outer*0x10) + inner);
	// 		inner++;
	// 	}
	// 	outer++;
	// }

	// // for-inside-for with if/else branching
	// for dq x = 0; x < 3 ; x++; {
	// 	for dq y = 0; y < 3 ; y++; {
	// 		if x == y {
	// 			printHex(0xABCDEF);
	// 		} else {
	// 			printHex((x*0x100) + y);
	// 		}
	// 	}
	// }

	// // mixed logical conditions and short-circuit use
	// for dq k = 0; (k < 10) && (k != 7) ; k++; {
	// 	if (k > 2) && ((k < 5) || (k == 9)) {
	// 		printHex(0x100 + k);
	// 	} else {
	// 		printHex(0x10 + k);
	// 	}
	// }

	// // deep nesting: while -> for -> while with else-if chain
	// dq n = 0;
	// while n < 2 {
	// 	for dq m = 0; m < 2 ; m++; {
	// 		dq p = 0; // declared inside for-body scope
	// 		while p < 2 {
	// 			if (n == 1) && (m == 1) && (p == 1) {
	// 				printHex(0xDEAD);
	// 			} elif (n == 1) && (m == 0) {
	// 				printHex(0xBEEF);
	// 			} else {
	// 				printHex((n*0x64) + (m*0x0A) + p);
	// 			}
	// 			p++;
	// 		}
	// 	}
	// 	n++;
	// }

	// // for loop with both continue and break paths
	// for dq a2 = 0; a2 < 10 ; a2++; {
	// 	if a2 == 3 {
	// 		continue;
	// 	}
	// 	if a2 == 5 {
	// 		break;
	// 	}
	// 	printHex(0xF00 + a2);
	// }

	// // while loop that flips a flag and uses continue to re-check
	// dq flag = 0;
	// dq i2 = 0;
	// while i2 < 6 {
	// 	if (i2 == 2) && (flag == 0) {
	// 		flag = 1;
	// 		i2++;
	// 		continue;
	// 	}
	// 	printHex(0xAA00 + i2);
	// 	i2++;
	// }

	

	

	return;
}
