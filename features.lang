global{
    dq aGlob = 5;
}

// include can be done like->  include("test3.lang")
include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")

struct MyStruct {
    dq field1;
    dq field2;
    db field3;
}

struct MyStruct2 {
	db field1;
	db field2;
	db field3;
	db field4;
	db field5 MyStruct<1>;
	db field5 db<4>;
	db field6;
}



func structsT(){
	ptr structName<MyStruct> = MyStruct{1,2,3};

	ptr test<MyStruct2> = MyStruct2{};

    printHex(structName);
    printHex(structName.field1);
    printHex(structName.field2);
    printHex(structName.field3);
    printHex(test);
	return;
}

func vars(){
	dq a = 10;
	dd b = 5;
	dw c = 2;
	db d = 1;

	a++;
	a++;
	a--;

	b++;
	b++;
	b--;

	c++;
	c++;
	c--;

	d++;
	d++;
	d--;

	printHex(a);
	printHex(b);
	printHex(c);
	printHex(d);

	//negative symbol and type affirmation
	printHex(-dq(a));
	printHex(-dd(b));
	printHex(-dw(c));
	printHex(-db(d));

	return;
}


func flow(){
	//whiles
	dd a = 0;
	while a < 5 {
		printHex(a);
		a++;
	}

	//fors
	for dq i = 0; i < 5; i++; {
		printHex(i);
	}
	//ifs

	if a == 5 {
		printHex(a);
	}

	if a != 6 {
		printHex(a);
	}

	if a > 4 {
		printHex(a);
	}

	if a < 6 {
		printHex(a);
	}


	if a != 5{
		printHex(0xff);
	}elif a == 5{
		printHex(0xff00);
	}

	if a != 5{
		printHex(0xff);
	}elif a == 6{
		printHex(0xff00);
	}else {
		printHex(0xff0000);
	}

	while a > 0 {
		printHex(a);
		break;
	}

	for dq i = 0; i < 5; i++; {
		if i >= 1 {
			continue;
		}
		printHex(i);
	}

	return;
}

func pointers(){
	dq a = 5;
	dd b = 6;
	dw c = 7;
	db d = 8;

	ptr aP<dq> = &a;
	ptr bP<dd> = &b;
	ptr cP<dw> = &c;
	ptr dP<db> = &d;

	ptr aPP<dq> = &aP;
	ptr bPP<dd> = &bP;
	ptr cPP<dw> = &cP;
	ptr dPP<db> = &dP;

	printHex(*aP);
	printHex(*bP);
	printHex(*cP);
	printHex(*dP);

	printHex(**aPP);
	printHex(**bPP);
	printHex(**cPP);
	printHex(**dPP);

	return;
}


func strings(){
	ptr str = "Hello, World!\n";
	printHex(str);
	print(str);
	return;
}

func functionParams(dq a, dd b, dw c, db d, ptr e<dd>){
	printHex(a);
	printHex(b);
	printHex(c);
	printHex(d);
	printHex(*e);
	return;
}

global{
    dq aGlob2 = 10;
}

func globalVars(){
	printHex(aGlob);
	printHex(aGlob2);
	return;
}

func arraysT(){

	dq arr<dq> = dq{1,2,3,4,5};
	printHex(arr);

	for dq i = 0; i < 5; i++; {
		printHex(arr[i]);
	}

	dq matrix<dq> = dq{dq{1, 2}, dq{3, 4}};
	for dq i = 0; i < 2; i++; {
		for dq j = 0; j < 2; j++; {
			printHex(matrix[i][j]);
		}
	}

	return;
}

func arithmetics(){
	dq a = 5;
	dd b = 10;
	dw c = 15;
	db d = 20;

	printHex(a + b);
	printHex(b - c);
	printHex(c * d);
	printHex(d / a);

	return;
}


func kernelInfo2(){

	ptr memInfo = db<390>;

	asm(mov64_r_i, rax, 63);
	loadReg(rdi, memInfo);
	asm(syscall);

	for dq i = 0; i < 6; i++; {
		print(memInfo + (i * 65));
		print("\n");
	}
	return;
}

struct utsname {
    db domainname db<65>;
    db machine db<65>;  
    db version db<65>; 
    db release db<65>;
    db nodename db<65>; 
    db sysname db<65>;   
}

func kernelInfo(){
	ptr structName<utsname> = utsname{};

	asm(mov64_r_i, rax, 63);
	loadReg(rdi, structName);
	asm(syscall);

	printHex(structName.sysname); //first letter
	print(&structName.sysname);
	print("\n");
	print(&structName.nodename);
	print("\n");
	print(&structName.release);
	print("\n");
	print(&structName.version);
	print("\n");
	print(&structName.machine);
	print("\n");
	print(&structName.domainname);
	return;
}

func retornoDQ(){
	dq res = 0x0123456789abcdef;
	return res;
}

func retornoDD(){
	dd res = 0x0123456789abcdef;
	return res;
}

func retornoDW(){
	dw res = 0x0123456789abcdef;
	return res;
}

func retornoDB(){
	db res = 0x0123456789abcdef;
	return res;
}

func clock_gettimeExec(){
	ptr ts<timespec> = timespec{};
	clock_gettime(ts);
	printHex(ts.tv_sec);
	printHex(ts.tv_nsec);
	return;
}

func worker1(dq p1, dd p2, dw p3, db p4){
	nanosleep(0, 100000000); //work pesadao
	print("worker1(): p1 p2 p3 p4\n");
	printHex(p1);
	printHex(p2);
	printHex(p3);
	printHex(p4);
	return;
}

func worker2(){
	print("worker2(): no params\n");
	return;
}

func testThreadsCARALHOS(){

	dq p1 = 0x1111111122222222;
	dq p2 = 0x3333333344444444;
	dd p3 = 0x5555555566666666;
	dw p4 = 0x6666666677777777;

	dq stack_size = 8 * 4096;
	dq t1_id; dq stack_t1 = mmap(8);
	dq t2_id; dq stack_t2 = mmap(8);


	//creating thread 1 with 4 params
	addThreadVariable(stack_t1, stack_size, p1, 0);
    addThreadVariable(stack_t1, stack_size, p2, 1);
    addThreadVariable(stack_t1, stack_size, p3, 2);
    addThreadVariable(stack_t1, stack_size, p4, 3);

	createThreadIds(&worker1, stack_t1, stack_size, &t1_id, 0, 4);

	//creating thread 2 with no params
	createThreadIds(&worker2, stack_t2, stack_size, &t2_id, 0, 0);

	print("Threads created, joining...\n");
	threadJoin(&t1_id);
	print("Joined thread 1\n");
	threadJoin(&t2_id);
	print("Joined thread 2\n");
	return;
}

func main(dq argc){

	structsT();
	print("\n");
	vars();
	print("\n");
	flow();
	print("\n");
	pointers();
	print("\n");
	strings();
	print("\n");

	dq e = 0xdeadbeefcafebabe;
	functionParams(1, 2, 3, 4, &e);

	print("\n");
	globalVars();
	print("\n");
	arraysT();
	print("\n");
	arithmetics();
	print("\n");
	kernelInfo();
	print("\n");
	kernelInfo2();
	printHex(retornoDQ());
	printHex(retornoDD());
	printHex(retornoDW());
	printHex(retornoDB());
	printHex(dd(retornoDQ()));
	printHex(dw(retornoDQ()));
	printHex(db(retornoDQ()));

	ptr stringMem = db<200>;
	memset(stringMem, 200, 0);
	read(stringMem, 200);
	reverseString(stringMem);
	print(stringMem);


	//cannot be called inside defer cause its another func
	dq rbpVar;
	loadVar(rbpVar, rbp);
	ptr args<dq> = getArgsPtr(argc, rbpVar);

	for dq i = 0; i < argc; i++; {
		print("arg ");
		print(args[i]);
		print("\n");
	}

	testThreadsCARALHOS();

	nanosleep(1,0);
	clock_gettimeExec();
	exit(69);

    return;
}
