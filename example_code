include "ficheiro_include"


func allocMem1Page(dd pge){
    dd page = pge * 4096;
    asm(mov32 eax 192);
    asm(mov32 ebx 0);
    asm(mov32 ecx page);
    asm(mov32 edx 3);
    asm(mov32 esi 34);
    asm(mov32 edi -1);
    asm(syscall);
    return;
}

func createString(){
    asm(pusha);
    dd page1 = allocMem1Page(2);
    asm(popa);
    return page1;
}

func setLetter(dd addr, dd offset, db letter, dw letter2){

    if letter2 = 65535{
        return 0;
    }

    asm(mov32 ecx addr);
    asm(mov8 bl letter);
    asm(mov32 eax offset);
    asm(mov8_mr_r ecx eax bl);

    return 0;
}


func getStringLen(dd addr){
    dd len = 0;

    while 1 = 1{

        db letter = 0;
        
        asm(mov32 ebx 0);
        asm(mov32 ecx addr);
        asm(mov32 eax len);
        asm(mov8_r_mr bl ecx eax);
        asm(mov8 letter bl);

        if letter = 0 {
            return len;
        }
        len = len + 1;
    }

    return len;
}

func printString(dd addr){

    dd len = getStringLen(addr);

    asm(mov32 ecx addr);
    asm(mov32 ebx 1);
    asm(mov32 edx len);
    asm(mov32 eax 4);
    asm(syscall);
    return 0;
}

func printStringLen(dd addr, dd len){

    asm(mov32 ecx addr);
    asm(mov32 ebx 1);
    asm(mov32 edx len);
    asm(mov32 eax 4);
    asm(syscall);
    return 0;
}

func floatAdd(dd a, dd b){
    asm(mov32 eax a);
    asm(mov_x_r xmm0 eax);
    asm(mov32 eax b);
    asm(mov_x_r xmm1 eax);
    asm(addss xmm0 xmm1);
    asm(mov_r_x eax xmm0);
    return;
}

func floatMul(dd a, dd b){
    asm(mov32 eax a);
    asm(mov_x_r xmm0 eax);
    asm(mov32 eax b);
    asm(mov_x_r xmm1 eax);
    asm(mulss xmm0 xmm1);
    asm(mov_r_x eax xmm0);
    return;
}

func floatSub(dd a, dd b){
    asm(mov32 eax a);
    asm(mov_x_r xmm0 eax);
    asm(mov32 eax b);
    asm(mov_x_r xmm1 eax);
    asm(subss xmm0 xmm1);
    asm(mov_r_x eax xmm0);
    return;
}

func floatDiv(dd a, dd b){
    asm(mov32 eax a);
    asm(mov_x_r xmm0 eax);
    asm(mov32 eax b);
    asm(mov_x_r xmm1 eax);
    asm(divss xmm0 xmm1);
    asm(mov_r_x eax xmm0);
    return;
}

func convertFloatToInt(dd a){
    asm(mov32 eax a);
    asm(mov_x_r xmm0 eax);
    asm(cvtss2si eax xmm0);
    return;
}

func convertIntToFloat(dd a){
    asm(mov32 eax a);
    asm(cvtsi2ss xmm0 eax);
    asm(mov_r_x eax xmm0);
    return;
}


func main(){

    // dd testelf = 0;
    // if 1 = 0 {
    //     testelf = testelf + 351;
    // }elif 1 = 2 {
    //     testelf = testelf + 349;
    // }else {
    //     testelf = testelf + 350;
    // }

    // return testelf;

    dd total = 0;

    // Testes individuais
    total = total + test();               // Espera 10
    total = total + test_whiles();        // Espera 10
    total = total + test_deaddressing();  // Espera 10
    total = total + test_ifs();           // Espera 10
    total = total + test_fors();          // Espera 10
    total = total + testRecursion(0);     // Espera 10
    total = total + test_params(4,1,0,2,3); // Espera 10
    total = total + nestedForLoops();     // Espera 100
    total = total + nestedIfs();          // Espera 10
    total = total + ret10if10(10);        // Espera 10
    total = total + forlooptest();        // Espera 45
    total = total + forlooptest2();             // Espera 10
    total = total + test_gates();             // Espera 35
    total = total + test_and_only();             // Espera 1
    total = total + test_and_false();             // Espera 0
    total = total + test_or_only();             // Espera 0
    total = total + test_or_true();             // Espera 1
    total = total + test_while_gate();             // Espera 6
    total = total + test_precedence();             // Espera 1
    total = total + test_nested_gates();             // Espera 1
    total = total + test_nested_gates_fail();             // Espera 0
    total = total + forloop_gate_test();             // Espera 5
    
    total = total + test_simple_gate1();             // Espera 5
    total = total + test_simple_gate2();     // Espera 0
    total = total + test_complex_gate();     // Espera 50
    total = total + test_gate_with_numbers();// Espera 300
    total = total + test_gate_with_arithmetic();// Espera 5
    total = total + test_gate_multiple();    // Espera 500
    total = total + test_gate_false();       // Espera 1000
    total = total + test_gate_nested_like(); // Espera 999

    total = total + testing_else1();      // Espera 10
    total = total + testing_else2();      // Espera 10
    total = total + testing_else3();      // Espera 10
    total = total + testing_else10();      // Espera 10
    total = total + testing_elif1();      // Espera 10
    total = total + testing_elif2();      // Espera 10
    total = total + testing_elif3();      // Espera 10
    total = total + testing_elif10();      // Espera 10
    total = total + testing_elif11();      // Espera 10

    total = total + testeNot();      // Espera 10
    total = total + testeNot2();      // Espera 10


    if total ! 3359 {
        return 0;
    }


    dd addr = createString();

    db H = 'P';
    db E = 'E';

    H = 65352;

    setLetter(addr, 0, H, 4294967294);
    setLetter(addr, 1, E, 0);
    setLetter(addr, 2, 'L', 0);
    setLetter(addr, 3, 'L', 0);
    setLetter(addr, 4, 'O', 0);
    setLetter(addr, 5, 'O', 0);
    setLetter(addr, 6, '_', 0);
    setLetter(addr, 7, 'M', 0);
    setLetter(addr, 8, 'U', 0);
    setLetter(addr, 9, 'N', 0);
    setLetter(addr, 10, 'D', 0);
    setLetter(addr, 11, 'O', 0);
    setLetter(addr, 12, 10, 0);

    asm(mov32 eax addr);
    asm(mov32 ebx 1);
    asm(mov32 ecx 65);
    asm(mov16_mr_r eax ebx ecx);

    printStringLen(addr, 13);

    dd s;
    CString("Hello World\n");
    asm(mov32 s eax);

    dd s2 = CString("Hello World2\n");

    //example comment
    printString(s);     // ola
    printString(s2);

    printString(CString("Hello World3\n"));



    dd teste = 0;
    asm(subi esp 4);
    asm(mov32 eax 65);
    asm(mov32_m_r esp  eax);
    asm(mov32 ebx 0);
    asm(mov32_r_mr eax esp ebx);
    asm(mov32 teste eax);
    asm(pop edx);


    dd testESPEBP = 0;
    //testing all 32 functions with esp and ebp regs :D
    //ESP TESTING
    //mov32_m_r
    asm(subi esp 4);
    asm(mov32 eax 10);
    asm(mov32_m_r esp eax);
    asm(pop eax);
    asm(mov32 testESPEBP eax);
    
    if testESPEBP ! 10 {
        return 0;
    }

    //mov32_r_m
    asm(mov32 ebx 15);
    asm(push ebx);
    asm(mov32_r_m eax esp);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 15 {
        return 0;
    }   


    //mov32_r_mi
    asm(mov32 ebx 20);
    asm(push ebx);
    asm(subi esp 4);
    asm(mov32_r_mi eax esp 4);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 20 {
        return 0;
    }


    //mov32_r_mr
    asm(mov32 ebx 25);
    asm(push ebx);
    asm(subi esp 4);
    asm(subi esp 4);
    asm(mov32 eax 8);
    asm(mov32_r_mr ebx esp eax);
    asm(mov32 testESPEBP ebx);

    if testESPEBP ! 25 {
        return 0;
    }

    //mov32_m_i
    asm(subi esp 4);
    asm(mov32_m_i esp 30);
    asm(pop eax);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 30 {
        return 0;
    }


    //mov32_m_r
    asm(subi esp 4);
    asm(mov32 ebx 35);
    asm(mov32_m_r esp ebx);
    asm(pop eax);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 35 {
        return 0;
    }


    //mov32_mi_r
    asm(subi esp 4);
    asm(subi esp 4);
    asm(mov32 ebx 40);
    asm(mov32_mi_r esp 4 ebx);
    asm(pop eax);
    asm(pop eax);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 40 {
        return 0;
    }


    //mov32_16_mr_r
    asm(subi esp 4);
    asm(subi esp 4);
    asm(mov32 ebx 4);
    asm(mov32 eax 50);
    asm(mov32_mr_r esp ebx eax);
    asm(pop eax);
    asm(pop eax);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 50 {
        return 0;
    }


    //EBP TESTING
    //detting ebp - esp
    //mov32_16_mr_r
    asm(subi esp 4);
    asm(mov32 eax ebp);
    asm(mov32 ebx esp);
    asm(sub eax ebx);
    asm(neg eax);
    asm(mov32 ebx 55);
    asm(mov32_mr_r ebp eax ebx);
    asm(pop eax);
    asm(mov32 testESPEBP eax);

    if testESPEBP ! 55 {
        return 0;
    }

    

  

    if teste = 65 {
        dd valor1 = CFloat(3.0);
        dd valor2 = CFloat(3.0);
        
        dd testeFloat = floatAdd(valor1, valor2);
        dd testeFconvert = convertFloatToInt(testeFloat);
        
        dd testeMul = floatMul(valor1, valor2);
        dd testeSub = floatSub(testeMul, valor1);
        dd testeDiv = floatDiv(testeMul, valor1);
        dd testeIntToFloat = convertIntToFloat(testeFconvert);


        if testeFconvert = 6 {
            if testeMul = CFloat(9.0) {
                if testeSub = CFloat(6.0) {
                    if testeDiv = CFloat(3.0) {
                        if testeIntToFloat = floatAdd(CFloat(3.0), CFloat(3.0)) {
                            return 350;
                        }
                    }
                }
            }
        }
    }

    return 0;
}