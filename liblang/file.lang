// Basic file utilities: open a file, determine size, allocate mmap buffer, read entire contents

global{
    dq O_RDONLY = 0;
    dq SEEK_SET = 0;
    dq SEEK_CUR = 1;
    dq SEEK_END = 2;
}

struct Stat{ // minimal subset for size (offset 48 on x86_64 but we'll read via fstat syscall into this layout)
    dq _pad1 dq<6>; // device/inode/mode/etc (simplified placeholder)
    dq size;        // we only care about st_size (approx position)
    dq _rest dq<7>; // padding to keep struct large enough
}

func sys_open(ptr path, dq flags){
    asm(mov64_r_i, rax, 2);
    loadReg(rdi, path);
    loadReg(rsi, flags);
    asm(mov64_r_i, rdx, 0); // mode unused for read
    asm(syscall);
    return;
}


func sys_lseek(dq fd, dq offset, dq whence){
    asm(mov64_r_i, rax, 8);
    loadReg(rdi, fd);
    loadReg(rsi, offset);
    loadReg(rdx, whence);
    asm(syscall);
    return;
}

// Returns pointer to buffer (mmap) and length via out pointer
func readFileToMmap(ptr path, ptr out_len){
    dq fd = sys_open(path, O_RDONLY);
    if fd < 0 { return 0; }

    // Determine size via lseek
    dq cur = sys_lseek(fd, 0, SEEK_CUR);
    dq fsize = sys_lseek(fd, 0, SEEK_END);
    if fsize <= 0 { sys_close(fd); return 0; }
    // rewind
    dq back = sys_lseek(fd, cur, SEEK_SET);

    // number of pages needed
    dq pages = fsize / 4096;
    if (fsize % 4096) != 0 { pages = pages + 1; }
    ptr buf = mmap(pages);
    if buf == 0 { sys_close(fd); return 0; }

    dq r = sys_read(fd, buf, fsize);
    // Add NUL terminator if space available
    if r == fsize { buf[fsize] = 0; }
    sys_close(fd);
    if r != fsize { return 0; }

    if out_len != 0 { *<dq>out_len = fsize; }
    return buf;
}
