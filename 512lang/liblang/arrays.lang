//depends on liblang/mem.lang

//worls only with arrays of dq
func remove_item_by_value(dq arr, dq length, dq value){
	if length == 0 { return 0; }
	dq i = 0;
	while i < length {
		if arr[i] == value {
			// shift remaining items left
			dq j = i;
			while j < (length - 1) {
				arr[j] = arr[j + 1];
				j++;
			}
			return length - 1; // new length
		}
		i++;
	}
	return length; // unchanged length
}

func remove_item_by_data(dq arr, dq length, ptr value, dq value_size){
    if length == 0 { return 0; }
    dq i = 0;
    while i <= (length - value_size) {
        if cmpmem(arr + i, value, value_size) == 1 {
            // Shift remaining bytes left by value_size
            shift_left_bytes(arr + i, length - i, value_size);
            return length - value_size;
        }
        i += value_size; // step by element size
    }
    return length;
}


func copy_item_by_index_to_arr(dq arr, dq arr_length_bytes, dq index, ptr value, dq value_size){
	index = index * value_size; // convert to byte index
	if (index >= arr_length_bytes) { return -1; } 
	if (index + value_size) > arr_length_bytes { return -2; }
	dq i = 0;
	while i < value_size {
		arr[index + i] = value[i];
		i++;
	}
	return 0; // success
}

func copy_item_by_index_to_var(ptr var_ptr, dq var_length, dq arr, dq arr_length, dq index){
	index = index * var_length; // convert to byte index
	if (index >= arr_length) { return -1; } 
	if (index + var_length) > arr_length { return -2; }
	dq i = 0;
	while i < var_length {
		var_ptr[i] = arr[index + i];
		i++;
	}
	return 0; // success
}