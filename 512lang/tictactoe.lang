include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")
include("liblang/net.lang")
include("liblang/floats.lang")
include("liblang/file.lang")

//constant vars
global{
	db GAME_CURRENT_PLAYER = 17;
	db GAME_FIRST_CUBE = 0x4a;
	db GAME_X_DIFF =  6;
	db GAME_Y_DIFF =  22;
}

global{
	dq tutorial = "
  Press a number to place your mark:\n

	    7  |  8  |  9                \n
	    4  |  5  |  6                \n
	    1  |  2  |  3                \n
	\n";
	dq game = "
  	  Its player x turn\n
	       |     |     \n
	       |     |     \n
	       |     |     \n
	\n";

	db playerNow = 0;
}



func printChar(ptr label, db value){
	dq buf = db<2>;
	print(label);
	buf[0] = value;
	buf[1] = 0;
	print(buf);
	return;
}


func get_position(dq x, dq y){
	if x < 0 || x > 2 || y < 0 || y > 2 {
		print("Invalid position\n");
		exit(1);
	}
	dq res = GAME_FIRST_CUBE + (x * GAME_X_DIFF) - (y * GAME_Y_DIFF);
	return res;
}

func game_init(dq gamePtr<db>){
	playerNow = 0;
	gamePtr[GAME_CURRENT_PLAYER] = 'X';
}

func game_ended(dq gamePtr<db>){
	//check rows 
	for dq i = 0; i < 3; i++; {
		dq pos1 = get_position(0,i);
		dq pos2 = get_position(1,i);
		dq pos3 = get_position(2,i);
		if (gamePtr[pos1] == gamePtr[pos2]) && (gamePtr[pos2] == gamePtr[pos3]) && (gamePtr[pos1] != ' ') {
			printChar("Player ", gamePtr[pos1]);
			print(" wins!\n");
			print(game);
			exit(0);
		}
	}

	//check columns 
	for dq i = 0; i < 3; i++; {
		dq pos1 = get_position(i,0);
		dq pos2 = get_position(i,1);
		dq pos3 = get_position(i,2);
		if (gamePtr[pos1] == gamePtr[pos2]) && (gamePtr[pos2] == gamePtr[pos3]) && (gamePtr[pos1] != ' ') {
			printChar("Player ", gamePtr[pos1]);
			print(" wins!\n");
			print(game);
			exit(0);
		}
	}

	//check diagonals
	dq pos1Dig1 = get_position(0,0);
	dq pos2Dig1 = get_position(1,1);
	dq pos3Dig1 = get_position(2,2);
	if (gamePtr[pos1Dig1] == gamePtr[pos2Dig1]) && (gamePtr[pos2Dig1] == gamePtr[pos3Dig1]) && (gamePtr[pos1Dig1] != ' ') {
		printChar("Player ", gamePtr[pos1Dig1]);
		print(" wins!\n");
		print(game);
		exit(0);
	}

	dq pos1Dig2 = get_position(2,0);
	dq pos2Dig2 = get_position(1,1);
	dq pos3Dig2 = get_position(0,2);
	if (gamePtr[pos1Dig2] == gamePtr[pos2Dig2]) && (gamePtr[pos2Dig2] == gamePtr[pos3Dig2]) && (gamePtr[pos1Dig2] != ' ') {
		printChar("Player ", gamePtr[pos1Dig2]);
		print(" wins!\n");
		print(game);
		exit(0);
	}

	//check if draw
	dq emptySpaces = 0;
	for dq y = 0; y < 3; y++; {
		for dq x = 0; x < 3; x++; {
			dq pos = get_position(x,y);
			if gamePtr[pos] == ' ' {
				emptySpaces++;
			}
		}
	}
	if emptySpaces == 0 {
		print("It's a draw!\n");
		print(game);
		exit(0);
	}
}

func get_current_place(dq gamePtr<db>){
	print(game);

	//input and set 0s
	dq input = db<5>;
	memset(input, 0, 5);

	//read input if valid
	read(input, 3);
	db place = input[0] - '0';
	if (place < 1) || (place > 9) {
		print("Invalid input. Please enter a number between 1 and 9.\n");
		return get_current_place(gamePtr);
	}

	dq x = (place - 1) % 3;
	dq y = (place - 1) / 3;

	if gamePtr[get_position(x,y)] != ' ' {
		print("Position already taken. Choose another.\n");
		return get_current_place(gamePtr);
	}

	if playerNow == 0 {
		gamePtr[get_position(x,y)] = 'X';
		playerNow = 1;
		gamePtr[GAME_CURRENT_PLAYER] = 'O';
	} else {
		gamePtr[get_position(x,y)] = 'O';
		playerNow = 0;
		gamePtr[GAME_CURRENT_PLAYER] = 'X';
	}
}

func main(dq argc){
	dq gamePtr<db> = game;
	game_init(gamePtr);

	print(tutorial);
	while 1 {
		get_current_place(gamePtr);
		game_ended(gamePtr);
	}
	return;
}
