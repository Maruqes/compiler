include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/arrays.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")
include("liblang/locks.lang")
include("liblang/net.lang")
include("liblang/floats.lang")
include("liblang/file.lang")


global{
	dq connections_arr = 0;
	dq connections_arr_size = 0;
	dq connections_count = 0;
	dq max_connections = 0;

	dq LOCK_connections_arr = 0;
	dq CONNECTIONS_MAP_SIZE = 30;
	dq THREAD_STACK_SIZE = 2;
}

struct thread_data{
	dq thread_id; //thread id from createThreadIds
	dq connection_memory;
	dq stack;
	dq dead;
}



func print_number_of_alive(){
	dq alive_count = 0;
	// Acquire lock before reading shared threads array
	lock_lock(&LOCK_connections_arr);
	dq i = 0;
	while i < connections_count {
		dq thread_var<thread_data> = thread_data{};
		SA_get_item_by_index_to_var(thread_var, sizeof(thread_data), connections_arr, connections_arr_size, i);
		if thread_var.dead == 0 {
			alive_count++;
		}
		i++;
	}
	lock_unlock(&LOCK_connections_arr);
	print_num("Number of alive connections: ", alive_count);
}

func get_dead_index(){
	// Acquire lock before reading shared threads array
	lock_lock(&LOCK_connections_arr);
	dq i = 0;
	while i < connections_count {
		dq thread_var<thread_data> = thread_data{};
		SA_get_item_by_index_to_var(thread_var, sizeof(thread_data), connections_arr, connections_arr_size, i);
		if thread_var.dead == 1 {
			lock_unlock(&LOCK_connections_arr);
			return i;
		}
		i++;
	}
	lock_unlock(&LOCK_connections_arr);
	return -1; // no dead found
}


func funcToCall(dq buffer){
	print("In funcToCall:\n");
	print(buffer);
	return;
}

func read_connection_buffer(dq accepted_socket, dq function_pointer){
	while 1 {
		dq buf = db<512>;
		memset(buf, 512, 0);
		dq rr = sys_recv(accepted_socket, buf, 512, 0);
		if rr < 0 {printHex(rr); print("recv() failed\n"); sys_close(accepted_socket); break; }
		if rr == 0 { print("Client disconnected\n"); sys_close(accepted_socket); break; }
		
		// function_pointer(buf);
		loadReg(rax, buf);
		asm(push64, rax);
		loadReg(rbx, function_pointer);
		asm(call_raw_address, rbx);
		asm(pop64, rax); //nao precisa de pop mas fica, porque o while limpa o stack anyway
	}
}

//index on connections_arr
func handle_connection(dq accepted_socket, dq index){
	read_connection_buffer(accepted_socket, &funcToCall);

	lock_lock(&LOCK_connections_arr);
	dq thread_var<thread_data> = SA_get_ptr_by_index(connections_arr, connections_arr_size, index, sizeof(thread_data));
	thread_var.dead = 1;
	lock_unlock(&LOCK_connections_arr);

	print_num("Thread handling connection exiting on index: ", index);
	return;
}


//if find unused set it there, if not just add at the end
func handle_thread_setup(dq accepted_socket){

	dq possible_index = get_dead_index();

	if possible_index == -1 {
		possible_index = connections_count; // reuse dead slot
	}

	//create thread at the last position
	//get a thread_data from connections_arr at connections_count index
	lock_lock(&LOCK_connections_arr);
	dq thread_var<thread_data> = SA_get_ptr_by_index(connections_arr, connections_arr_size, possible_index, sizeof(thread_data));
	lock_unlock(&LOCK_connections_arr);

	//setup thread_var
	if possible_index == -1 {
		threadJoin(&thread_var.thread_id);
		freeMmap(thread_var.stack, THREAD_STACK_SIZE);
	}
	thread_var.stack = mmap(THREAD_STACK_SIZE);
	if thread_var.stack == 0 { print("mmap() failed\n"); sys_close(accepted_socket); return; }
	thread_var.connection_memory = accepted_socket;
	thread_var.dead = 0;
	thread_var.thread_id = 0;
		
	//create thread to handle connection
	addThreadVariable(thread_var.stack,  THREAD_STACK_SIZE*4096, accepted_socket, 0); // pass variable to thread
	addThreadVariable(thread_var.stack,  THREAD_STACK_SIZE*4096, possible_index, 1); // pass variable to thread
	createThreadIds(&handle_connection, thread_var.stack, THREAD_STACK_SIZE*4096, &thread_var.thread_id, 0, 2); // create thread
	print_num("Spawned thread to handle connection number: ", possible_index);

	if possible_index == connections_count {
		connections_count++;
	}
}

func setup_memory_for_threads(){
	//setup connections_arr as non dead
	dq thread_var<thread_data> = thread_data{};
	thread_var.thread_id = 0;
	thread_var.connection_memory = 0;
	thread_var.stack = 0;
	thread_var.dead = 1; // mark as dead or unused
	dq i = 0;
	while i < max_connections {
		SA_set_item_by_index(connections_arr, connections_arr_size, i, &thread_var, sizeof(thread_data));
		i++;
	}
}

// for each connection, need to spawn a thread to handle it
func main(){

	create_lock(&LOCK_connections_arr);

	connections_arr = mmap(CONNECTIONS_MAP_SIZE); 
	if connections_arr == 0 { print("mmap() failed\n"); return; }
	connections_count = 0;
	max_connections = (CONNECTIONS_MAP_SIZE * 4096) / sizeof(thread_data);
	connections_arr_size = CONNECTIONS_MAP_SIZE * 4096;

	print_num("Starting server with slots: ", max_connections);
	dq sock = sys_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if sock < 0 { print("socket() failed\n"); return; }

    dq addr<sockaddr_in> = sockaddr_in{};
    addr.family = AF_INET;
    addr.port = htons(8080);
    addr.addr = htonl(0x7F000001); // 127.0.0.1

	dq bindRes = sys_bind(sock, addr, 16);
	if bindRes < 0 { print("bind() failed\n"); return; }

	dq listenRes = sys_listen(sock, 5);
	if listenRes < 0 { print("listen() failed\n"); return; }
	print("Listening on port 8080...\n");

	//accept loop
	while 1 {
		dq acceptRes = sys_accept(sock, 0, 0);
		if acceptRes < 0 { print("accept() failed\n"); nanosleep(0, 100000000); continue; }
		print("Client connected\n");
		
		handle_thread_setup(acceptRes);

		print_number_of_alive();

		// //recv
		// memset(buf, 512, 0);
		// //rr is length of received data
		// dq rr = sys_recv(acceptRes, buf, 512, 0);
		// if rr < 0 { print("recv() failed\n"); sys_close(acceptRes); continue; }
		// if rr == 0 { print("Client disconnected\n"); sys_close(acceptRes); continue; }
		// print("Received: ");
		// print(buf);

		// //send echo
		// dq sr = sys_send(acceptRes, buf, rr, 0);
		// if sr < 0 { print("send() failed\n"); sys_close(acceptRes); continue; }
		// print("Echoed back to client\n");

	}
}