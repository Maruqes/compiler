include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/arrays.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")
include("liblang/net.lang")
include("liblang/floats.lang")
include("liblang/file.lang")


global{
	dq connections_count = 0;
	dq max_connections = 0;

	dq threads_arr = 0;
	dq threads_count = 0;
	dq max_threads = 0;


	dq CONNECTIONS_MAP_SIZE = 5;
}

struct thread_data{
	dq thread_id;
	dq stack;
	dq dead;
}

func printAllConnections(){
	dq i = 0;
	print_num("Current connections: " , connections_count);
	while i < connections_count {
		dq thread_var<thread_data> = thread_data{};
		copy_item_by_index_to_var(thread_var, sizeof(thread_data), threads_arr, max_threads, i);
		print_num("Connection socket fd: ", connections_memory[i]);
		print_num(" | Thread ID: ", thread_var.thread_id);
		print_num(" | Dead: ", thread_var.dead);
		print("\n");
		i++;
	}
}


func check_dead_threads(){
	dq i = 0;
	while i < threads_count {
		dq thread_var<thread_data> = thread_data{};
		copy_item_by_index_to_var(thread_var, sizeof(thread_data), threads_arr, max_threads, i);
		if thread_var.dead == 1 {
			print_num("Cleaning up dead thread at index: ", i);
			// threadJoin(&thread_var.thread_id);
			freeMmap(thread_var.stack, CONNECTIONS_MAP_SIZE);
			remove_item_by_data(threads_arr, threads_count * sizeof(thread_data), thread_var, sizeof(thread_data));
			threads_count--;
			i--; // stay at same index for next iteration since we shifted left
		}
		i++;
	}
}

func funcToCall(dq buffer){
	print("In funcToCall:\n");
	print(buffer);
	return;
}

func read_connection_buffer(dq accepted_socket, dq function_pointer){
	while 1 {
		dq buf = db<512>;
		memset(buf, 512, 0);
		dq rr = sys_recv(accepted_socket, buf, 512, 0);
		if rr < 0 {printHex(rr); print("recv() failed\n"); sys_close(accepted_socket); break; }
		if rr == 0 { print("Client disconnected\n"); sys_close(accepted_socket); break; }
		
		// function_pointer(buf);
		loadReg(rax, buf);
		asm(push64, rax);
		loadReg(rbx, function_pointer);
		asm(call_raw_address, rbx);
		asm(pop64, rax); //nao precisa de pop mas fica, porque o while limpa o stack anyway
	}
}

//index on threads_arr
func handle_connection(dq accepted_socket, dq index){
	read_connection_buffer(accepted_socket, &funcToCall);
	dq newCount = remove_item_by_value(connections_memory, connections_count, accepted_socket);
	connections_count = newCount;

	//get thread_data from threads_arr and set as dead
	dq thread_var<thread_data> = thread_data{};
	copy_item_by_index_to_var(thread_var, sizeof(thread_data), threads_arr, max_threads, index);
	thread_var.dead = 1;
	copy_item_by_index_to_arr(threads_arr, max_threads, index, thread_var, sizeof(thread_data));

	print_num("Thread handling connection exiting on index: ", index);
	return;
}

func add_connection(dq accepted_socket){
	// check we have room for another connection
	if connections_count >= max_connections {
		print("Max connections reached, rejecting connection\n");
		sys_close(accepted_socket);
		return;
	}

	 dq cons<dq> = connections_memory;
	 cons[connections_count] = accepted_socket;
	 connections_count++;
	 print("Connection added.\n");
}

// for each connection, need to spawn a thread to handle it
func main(){

	connections_memory = mmap(CONNECTIONS_MAP_SIZE); 
	connections_count = 0;
	max_connections = (CONNECTIONS_MAP_SIZE * 4096) / 8; // 8 bytes per connection

	threads_arr = mmap(CONNECTIONS_MAP_SIZE * sizeof(thread_data)); //
	threads_count = 0;
	max_threads = (CONNECTIONS_MAP_SIZE * 4096) / sizeof(thread_data);

	print("Starting server...\n");
	dq sock = sys_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if sock < 0 { print("socket() failed\n"); return; }

    dq addr<sockaddr_in> = sockaddr_in{};
    addr.family = AF_INET;
    addr.port = htons(8080);
    addr.addr = htonl(0x7F000001); // 127.0.0.1

	dq bindRes = sys_bind(sock, addr, 16);
	if bindRes < 0 { print("bind() failed\n"); return; }

	dq listenRes = sys_listen(sock, 5);
	if listenRes < 0 { print("listen() failed\n"); return; }
	print("Listening on port 8080...\n");

	//accept loop
	while 1 {
		dq acceptRes = sys_accept(sock, 0, 0);
		if acceptRes < 0 { print("accept() failed\n"); break; }
		print("Client connected\n");
		
		add_connection(acceptRes);


		dq thread_var<thread_data> = thread_data{};
		thread_var.stack = mmap(CONNECTIONS_MAP_SIZE);
		thread_var.dead = 0;

		copy_item_by_index_to_arr(threads_arr, max_threads, threads_count, thread_var, sizeof(thread_data));
		addThreadVariable(thread_var.stack,  CONNECTIONS_MAP_SIZE*4096, acceptRes, 0); // pass variable to thread
		addThreadVariable(thread_var.stack,  CONNECTIONS_MAP_SIZE*4096, threads_count, 1); // pass variable to thread
		createThreadIds(&handle_connection, thread_var.stack, CONNECTIONS_MAP_SIZE*4096, &thread_var.thread_id, 0, 2); // create thread
		print("Spawned thread to handle connection\n");
		threads_count++;

		printAllConnections();

		check_dead_threads();
		print("\n");
		printAllConnections();

		print("\n");
		print("\n");
		print("\n");


		// //recv
		// memset(buf, 512, 0);
		// //rr is length of received data
		// dq rr = sys_recv(acceptRes, buf, 512, 0);
		// if rr < 0 { print("recv() failed\n"); sys_close(acceptRes); continue; }
		// if rr == 0 { print("Client disconnected\n"); sys_close(acceptRes); continue; }
		// print("Received: ");
		// print(buf);

		// //send echo
		// dq sr = sys_send(acceptRes, buf, rr, 0);
		// if sr < 0 { print("send() failed\n"); sys_close(acceptRes); continue; }
		// print("Echoed back to client\n");

	}
}