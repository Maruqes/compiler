global{
    dq aGlob = 5;
}

// include can be done like->  include("test3.lang")
include("liblang/min.lang")
include("liblang/mem.lang")
include("liblang/strings.lang")
include("liblang/threads.lang")
include("liblang/net.lang")

struct Struct1{
    dq a;
    dq arr dq<2>;
    dq b;
}

struct Struct2{
    dq a;
    dq s1s Struct1<2>;
    dq b;
}




func structsT(){
	// Struct1: show both ways to access the inline dq[2] field "arr"
	ptr s<Struct1> = Struct1{};
	s.a = 1;
	s.b = 4;

	// Method 1: raw deref on field address
	*<dq>(&s.arr) = 2;
	*<dq>(&s.arr + sizeof(dq)) = 3;

	// Method 2: take a dq* to the array and index it
	ptr s_arr<dq> = &s.arr;

	printHex(s.a);
	printHex(*<dq>(&s.arr));                      // 2
	printHex(*<dq>(&s.arr + sizeof(dq)));         // 3
	printHex(s_arr[0]);                           // 2
	printHex(s_arr[1]);                           // 3
	printHex(s.b);

	// Also write via indexing and read back via raw deref to show equivalence
	s_arr[0] = 20;
	s_arr[1] = 30;
	printHex(*<dq>(&s.arr));                      // 20
	printHex(*<dq>(&s.arr + sizeof(dq)));         // 30

	// Struct2: array of Struct1 inside a struct
	ptr s2<Struct2> = Struct2{};
	s2.a = 1;
	s2.b = 6;

	// Base pointer to first element of "s1s" (Struct1[2])
	ptr s2s_1<Struct1> = &s2.s1s;
	ptr s2s_2<Struct1> = &s2.s1s + sizeof(Struct1);
	

	// Element 0: use raw deref for its inner dq[2]
	s2s_1.a = 2;
	s2s_1.b = 5;
	*<dq>(&s2s_1.arr) = 3;
	*<dq>(&s2s_1.arr + sizeof(dq)) = 4;

	printHex(s2s_1.a);
	printHex(*<dq>(&s2s_1.arr));
	printHex(*<dq>(&s2s_1.arr + sizeof(dq)));
	printHex(s2s_1.b);

	// Element 1: use a dq* and index it
	ptr arr1<dq> = &s2s_2.arr;
	s2s_2.a = 3;
	s2s_2.b = 8;
	arr1[0] = 4;
	arr1[1] = 5;

	printHex(s2s_2.a);
	printHex(arr1[0]);
	printHex(arr1[1]);
	printHex(s2s_2.b);
	return;
}

func vars(){
	dq a = 10;
	dd b = 5;
	dw c = 2;
	db d = 1;

	a++;
	a++;
	a--;

	b++;
	b++;
	b--;

	c++;
	c++;
	c--;

	d++;
	d++;
	d--;

	printHex(a);
	printHex(b);
	printHex(c);
	printHex(d);

	//negative symbol and type affirmation
	printHex(-dq(a));
	printHex(-dd(b));
	printHex(-dw(c));
	printHex(-db(d));

	return;
}


func flow(){
	//whiles
	dd a = 0;
	while a < 5 {
		printHex(a);
		a++;
	}

	//fors
	for dq i = 0; i < 5; i++; {
		printHex(i);
	}
	//ifs

	if a == 5 {
		printHex(a);
	}

	if a != 6 {
		printHex(a);
	}

	if a > 4 {
		printHex(a);
	}

	if a < 6 {
		printHex(a);
	}


	if a != 5{
		printHex(0xff);
	}elif a == 5{
		printHex(0xff00);
	}

	if a != 5{
		printHex(0xff);
	}elif a == 6{
		printHex(0xff00);
	}else {
		printHex(0xff0000);
	}

	while a > 0 {
		printHex(a);
		break;
	}

	for dq i = 0; i < 5; i++; {
		if i >= 1 {
			continue;
		}
		printHex(i);
	}

	return;
}

func pointers(){
	dq a = 5;
	dd b = 6;
	dw c = 7;
	db d = 8;

	ptr aP<dq> = &a;
	ptr bP<dd> = &b;
	ptr cP<dw> = &c;
	ptr dP<db> = &d;

	*<dq>aP = 10;

	ptr aPP<dq> = &aP;
	ptr bPP<dd> = &bP;
	ptr cPP<dw> = &cP;
	ptr dPP<db> = &dP;

	printHex(*<dq>aP);
	printHex(*<dd>bP);
	printHex(*<dw>cP);
	printHex(*<db>dP);

	printHex(*<dq>*<dq>aPP);
	printHex(*<dd>*<dq>bPP);
	printHex(*<dw>*<dq>cPP);
	printHex(*<db>*<dq>dPP);

	return;
}

// Extra pointer stress tests: arrays, pointer arithmetic, multi-level pointers, struct fields, and heap buffers
func pointers_arrays(){
	// dq array and pointer indexing
	dq arr<dq> = dq{10, 20, 30, 40};
	ptr p<dq> = arr; // base pointer to first element
	print("p[0..3]\n");
	printHex(p[0]);
	printHex(p[1]);
	printHex(p[2]);
	printHex(p[3]);

	// modify via pointer and check array view
	p[2] = 333;
	printHex(arr[2]); // expect 333

	// element-sized pointer arithmetic (manual byte offset)
	ptr p2<dq> = p + sizeof(dq);
	printHex(*<dq>p2);      // expect 20
	printHex(p2[1]);        // expect 333

	// Multi-level pointers (single, double, triple)
	dq a = 5;
	ptr aP<dq> = &a;
	ptr aPP<dq> = &aP;
	ptr aPPP<dq> = &aPP;
	*<dq>aP = 42;
	printHex(*<dq>aP);                // 42
	printHex(*<dq>*<dq>aPP);          // 42
	printHex(*<dq>*<dq>*<dq>aPPP);    // 42

	// Array of addresses (store as dq, cast back to pointer)
	dq x = 100;
	dq y = 200;
	dq pArr<dq> = dq{&x, &y};
	ptr px<dq> = pArr[0];
	ptr py<dq> = pArr[1];
	*<dq>px = 111;
	*<dq>py = 222;
	printHex(x); // 111
	printHex(y); // 222

	// Struct field pointers and inline array field
	ptr s<Struct1> = Struct1{};
	ptr pa<dq> = &s.a;
	ptr parr<dq> = &s.arr;
	ptr pb<dq> = &s.b;
	*<dq>pa = 11;
	parr[0] = 22;
	parr[1] = 33;
	*<dq>pb = 44;
	printHex(s.a);                           // 11
	printHex(*<dq>(&s.arr));                 // 22
	printHex(*<dq>(&s.arr + sizeof(dq)));    // 33
	printHex(s.b);                           // 44

	// Heap buffer (brk) with typed views
	ptr buf = brk(32);
	if buf != -1 {
		// Byte view to write a small C-string
		ptr b8<db> = buf;
		b8[0] = 'A'; b8[1] = 'B'; b8[2] = 0;
		print(b8); // prints "AB"
		print("\n");

		// 32-bit view
		ptr w32<dd> = buf;
		w32[0] = 0x11223344;
		w32[1] = 0x55667788;
		printHex(w32[0]);
		printHex(w32[1]);

		// 64-bit view overlapping same buffer
		ptr w64<dq> = buf;
		// w64[0] contains lower 8 bytes (includes 0x11223344 and 0x55667788 bytes)
		w64[1] = 0xAABBCCDDEEFF0011;
		printHex(w64[0]);
		printHex(w64[1]);
	}

	return;
}

// Typed-pointer boundary and endianness tests for db/dw/dd/dq
func pointers_typed_bounds(){
	dq N = 32;
	ptr buf = brk(N);
	if buf == -1 { return; }
	memset(buf, N, 0);

	// Byte view: set first and last bytes
	ptr b<db> = buf;
	b[0]   = 0x11;
	b[N-1] = 0xAA;
	print("DB first/last:\n");
	printHex(b[0]);      // 11
	printHex(*<db>b);      // 11
	printHex(b[N-1]);    // AA
	printHex(*<db>(b + (N-1))); // AA

	// 16-bit view: write within bounds and at last valid index
	ptr w<dw> = buf;
	w[1] = 0xBEEF;       // bytes 2..3
	print("DW at 1 (bytes 2..3) + little-endian bytes:\n");
	printHex(w[1]);      // BEEF
	printHex(*<dw>(w + (1 * sizeof(dw)))); 
	printHex(b[2]);      // EF
	printHex(*<db>(b + 2));
	printHex(b[3]);      // BE
	printHex(*<db>(b + 3));
	dd last_dw = (N/2) - 1;
	w[last_dw] = 0x1234; // bytes N-2..N-1
	print("DW last index and tail bytes:\n");
	printHex(w[last_dw]);
	printHex(*<dw>(w + (last_dw * sizeof(dw))));
	printHex(b[N-2]);    // 34
	printHex(*<db>(b + (N-2)));
	printHex(b[N-1]);    // 12 (overwrites 0xAA)
	printHex(*<db>(b + (N-1)));

	// 32-bit view
	ptr d<dd> = buf;
	d[1] = 0xA1B2C3D4;   // bytes 4..7
	print("DD at 1 and bytes 4..7:\n");
	printHex(d[1]);
	printHex(*<dd>(d + (1 * sizeof(dd))));
	printHex(b[4]);      // D4
	printHex(*<db>(b + 4));
	printHex(b[5]);      // C3
	printHex(*<db>(b + 5));
	printHex(b[6]);      // B2
	printHex(*<db>(b + 6));
	printHex(b[7]);      // A1
	printHex(*<db>(b + 7));
	dd last_dd = (N/4) - 1;
	d[last_dd] = 0x10203040; // bytes N-4..N-1
	print("DD last index and final 4 bytes:\n");
	printHex(d[last_dd]);
	printHex(*<dd>(d + (last_dd * sizeof(dd))));
	printHex(b[N-4]);    // 40
	printHex(*<db>(b + (N-4)));
	printHex(b[N-3]);    // 30
	printHex(*<db>(b + (N-3)));
	printHex(b[N-2]);    // 20
	printHex(*<db>(b + (N-2)));
	printHex(b[N-1]);    // 10
	printHex(*<db>(b + (N-1)));

	// 64-bit view
	ptr q<dq> = buf;
	q[0] = 0x1122334455667788; // bytes 0..7
	print("DQ at 0 and bytes 0..7:\n");
	printHex(q[0]);
	printHex(*<dq>(q + 0));
	printHex(b[0]);      // 88
	printHex(*<db>(b + 0));
	printHex(b[1]);      // 77
	printHex(*<db>(b + 1));
	printHex(b[2]);      // 66
	printHex(*<db>(b + 2));
	printHex(b[3]);      // 55
	printHex(*<db>(b + 3));
	printHex(b[4]);      // 44
	printHex(*<db>(b + 4));
	printHex(b[5]);      // 33
	printHex(*<db>(b + 5));
	printHex(b[6]);      // 22
	printHex(*<db>(b + 6));
	printHex(b[7]);      // 11
	printHex(*<db>(b + 7));
	dd last_dq = (N/8) - 1;
	q[last_dq] = 0xFFEEDDCCBBAA0099; // bytes N-8..N-1
	print("DQ last index and last 8 bytes:\n");
	printHex(q[last_dq]);
	printHex(*<dq>(q + (last_dq * sizeof(dq))));
	printHex(b[N-8]);    // 99
	printHex(*<db>(b + (N-8)));
	printHex(b[N-7]);    // 00
	printHex(*<db>(b + (N-7)));
	printHex(b[N-6]);    // AA
	printHex(*<db>(b + (N-6)));
	printHex(b[N-5]);    // BB
	printHex(*<db>(b + (N-5)));
	printHex(b[N-4]);    // CC
	printHex(*<db>(b + (N-4)));
	printHex(b[N-3]);    // DD
	printHex(*<db>(b + (N-3)));
	printHex(b[N-2]);    // EE
	printHex(*<db>(b + (N-2)));
	printHex(b[N-1]);    // FF
	printHex(*<db>(b + (N-1)));

	return;
}

// Allocate heap and create typed "vars" at offsets using raw deref (*<type>)
func pointers_heap_vars(){
	dq N = 64;
	ptr base = brk(N);
	if base == -1 { return; }
	memset(base, N, 0);

	// Convenience byte view
	ptr b<db> = base;

	print("Heap vars: set/get via *<type> at offsets\n");

	// db at 0
	*<db>(base + 0) = 0x7F;
	printHex(*<db>(base + 0));
	ptr dbp<db> = base + 0;
	printHex(*<db>dbp);

	// dw at 2 (bytes 2..3)
	*<dw>(base + 2) = 0xBEEF;
	printHex(*<dw>(base + 2));
	printHex(b[2]); // EF
	printHex(b[3]); // BE

	// dd at 8 (bytes 8..11)
	*<dd>(base + 8) = 0xA1B2C3D4;
	printHex(*<dd>(base + 8));
	printHex(b[8]);  // D4
	printHex(b[9]);  // C3
	printHex(b[10]); // B2
	printHex(b[11]); // A1

	// dq at 16 (bytes 16..23)
	*<dq>(base + 16) = 0x1122334455667788;
	printHex(*<dq>(base + 16));
	printHex(b[16]); // 88
	printHex(b[17]); // 77
	printHex(b[18]); // 66
	printHex(b[19]); // 55
	printHex(b[20]); // 44
	printHex(b[21]); // 33
	printHex(b[22]); // 22
	printHex(b[23]); // 11

	// boundary: last byte
	*<db>(base + (N-1)) = 0xFF;
	printHex(*<db>(base + (N-1))); // FF

	// boundary: dd at last valid start (N-4)
	*<dd>(base + (N-4)) = 0x10203040;
	printHex(*<dd>(base + (N-4)));
	printHex(b[N-4]); // 40
	printHex(b[N-3]); // 30
	printHex(b[N-2]); // 20
	printHex(b[N-1]); // 10

	// boundary: dq at last valid start (N-8)
	*<dq>(base + (N-8)) = 0xFFEEDDCCBBAA0099;
	printHex(*<dq>(base + (N-8)));
	printHex(b[N-8]); // 99
	printHex(b[N-7]); // 00
	printHex(b[N-6]); // AA
	printHex(b[N-5]); // BB
	printHex(b[N-4]); // CC
	printHex(b[N-3]); // DD
	printHex(b[N-2]); // EE
	printHex(b[N-1]); // FF

	// demonstrate typed pointer variable referencing the same slot
	ptr qptr<dq> = base + 24;
	*<dq>qptr = 0xCAFEBABEDEADBEEF;
	printHex(*<dq>(base + 24));
	*<dq>qptr = *<dq>qptr + 1;
	printHex(*<dq>qptr);

	return;
}


func strings(){
	ptr str = "Hello, World!\n";
	printHex(str);
	print(str);
	return;
}

func functionParams(dq a, dd b, dw c, db d, ptr e<dd>){
	printHex(a);
	printHex(b);
	printHex(c);
	printHex(d);
	printHex(*<dd>e);
	return;
}

global{
    dq aGlob2 = 10;
}

func globalVars(){
	printHex(aGlob);
	printHex(aGlob2);
	return;
}

func arraysT(){

	dq arr<dq> = dq{1,2,3,4,5};
	printHex(arr);

	for dq i = 0; i < 5; i++; {
		printHex(arr[i]);
	}

	dq matrix<dq> = dq{dq{1, 2}, dq{3, 4}};
	for dq i = 0; i < 2; i++; {
		for dq j = 0; j < 2; j++; {
			printHex(matrix[i][j]);
		}
	}

	return;
}

func arithmetics(){
	// basic arithmetic
	dq a = 20;
	dq b = 6;
	dq c = 3;

	print("ADD/SUB/MUL/DIV\n");
	printHex(a + b); // 26
	printHex(a - b); // 14
	printHex(b * c); // 18
	printHex(a / c); // 6

	// modulus
	print("MOD\n");
	printHex(a % b); // 2

	// bitwise ops
	print("BITWISE\n");
	dq x = 0x1122334455667788;
	dq y = 0x0102030405060708;
	dq pStack = 0xffffffffffffffff;
	pStack = pStack & 0xfffffffffffffff0;
	printHex(pStack);
	printHex(x & y);
	printHex(x | y);
	printHex(x ^ y);

	// logical ops
	print("LOGICAL\n");
	dq t = 1;
	dq f = 0;
	printHex(t && t); // 1
	printHex(t && f); // 0
	printHex(f && t); // 0
	printHex(f || t); // 1
	printHex(t || f); // 1
	printHex(f || f); // 0

	// comparisons
	print("CMP\n");
	printHex(a == b); // 0
	printHex(a != b); // 1
	printHex(a <  b); // 0
	printHex(a <= b); // 0
	printHex(a >  b); // 1
	printHex(a >= b); // 1

	// shifts (amount in register)
	print("SHIFTS\n");
	dq sh = 5;
	x = 0x0123456789abcdef;
	printHex(x << sh);
	printHex(x >> sh);

	return;
}


func kernelInfo2(){

	ptr memInfo = db<390>;

	asm(mov64_r_i, rax, 63);
	loadReg(rdi, memInfo);
	asm(syscall);

	for dq i = 0; i < 6; i++; {
		print(memInfo + (i * 65));
		print("\n");
	}
	return;
}

struct utsname {
    db domainname db<65>;
    db machine db<65>;  
    db version db<65>; 
    db release db<65>;
    db nodename db<65>; 
    db sysname db<65>;   
}

func kernelInfo(){
	ptr structName<utsname> = utsname{};

	asm(mov64_r_i, rax, 63);
	loadReg(rdi, structName);
	asm(syscall);

	printHex(structName.sysname); //first letter
	print(&structName.sysname);
	print("\n");
	print(&structName.nodename);
	print("\n");
	print(&structName.release);
	print("\n");
	print(&structName.version);
	print("\n");
	print(&structName.machine);
	print("\n");
	print(&structName.domainname);
	return;
}

func retornoDQ(){
	dq res = 0x0123456789abcdef;
	return res;
}

func retornoDD(){
	dd res = 0x0123456789abcdef;
	return res;
}

func retornoDW(){
	dw res = 0x0123456789abcdef;
	return res;
}

func retornoDB(){
	db res = 0x0123456789abcdef;
	return res;
}

func clock_gettimeExec(){
	ptr ts<timespec> = timespec{};
	clock_gettime(ts);
	printHex(ts.tv_sec);
	printHex(ts.tv_nsec);
	return;
}

func worker1(dq p1, dd p2, dw p3, db p4){
	nanosleep(0, 100000000); //work pesadao
	print("worker1(): p1 p2 p3 p4\n");
	printHex(p1);
	printHex(p2);
	printHex(p3);
	printHex(p4);
	return;
}

func worker2(){
	print("worker2(): no params\n");
	return;
}

func testThreadsCARALHOS(){

	dq p1 = 0x1111111122222222;
	dq p2 = 0x3333333344444444;
	dd p3 = 0x5555555566666666;
	dw p4 = 0x6666666677777777;

	dq stack_size = 8 * 4096;
	dq t1_id; dq stack_t1 = mmap(8);
	dq t2_id; dq stack_t2 = mmap(8);


	//creating thread 1 with 4 params
	addThreadVariable(stack_t1, stack_size, p1, 0);
    addThreadVariable(stack_t1, stack_size, p2, 1);
    addThreadVariable(stack_t1, stack_size, p3, 2);
    addThreadVariable(stack_t1, stack_size, p4, 3);

	createThreadIds(&worker1, stack_t1, stack_size, &t1_id, 0, 4);

	//creating thread 2 with no params
	createThreadIds(&worker2, stack_t2, stack_size, &t2_id, 0, 0);

	print("Threads created, joining...\n");
	threadJoin(&t1_id);
	print("Joined thread 1\n");
	threadJoin(&t2_id);
	print("Joined thread 2\n");

	freeMmap(stack_t1, 8);
	freeMmap(stack_t2, 8);
	print("Finished all threads\n");
	return;
}


func read_stdin_sock(dq sock){
    dq msg = db<256>;
    while 1 {
        memset(msg, 256, 0);      
        dq n = read(msg, 255);    
        if n <= 0 {             
            break;
        }
        dq w = sys_send(sock, msg, n, MSG_NOSIGNAL);
        if w < 0 { print("send failed\n"); break; }
    }
    return;
}

func testTCP_lib(){
  	dq sock = sys_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if sock < 0 { print("socket() failed\n"); return; }

    dq addr<sockaddr_in> = sockaddr_in{};
    addr.family = AF_INET;
    addr.port = htons(8080);
    addr.addr = htonl(0x7F000001); // 127.0.0.1

    print("Attempt connect...\n");
    dq r = sys_connect(sock, addr, 16);
    if r < 0 { print("connect() failed\n"); return; }
    print("connected\n");

    
    //create thread to read stdin and send to socket
    dq t1_stack = mmap(5);
    dq t1_id = 0;
    addThreadVariable(t1_stack, 5*4096, sock, 0);
    createThreadIds(&read_stdin_sock, t1_stack, 5*4096, &t1_id, 0, 1);


	//loop reading from socket and printing to stdout
    dq buf = db<512>;
    while 1 {
        memset(buf, 512, 0);
        dq rr = sys_read(sock, buf, 512);
        if rr == 0 { print("peer closed\n"); break; }
        if rr < 0 { print("read failed\n"); break; }
        if rr > 0 { print(buf); }

        if strcmp(buf, "exit\n") {
            print("Exiting on 'exit' command\n");
            break;
        }
    }

    thkill(t1_id);
    sys_close(sock);
    // exit_group(0);
}

func main(dq argc){

	structsT();
	print("\n");
	vars();
	print("\n");
	flow();
	print("\n");
	pointers();
	print("\n");
	pointers_arrays();
	print("\n");
	pointers_typed_bounds();
	print("\n");
	pointers_heap_vars();
	print("\n");
	strings();
	print("\n");

	dq e = 0xdeadbeefcafebabe;
	functionParams(1, 2, 3, 4, &e);

	print("\n");
	globalVars();
	print("\n");
	arraysT();
	print("\n");
	arithmetics();
	print("\n");
	kernelInfo();
	print("\n");
	kernelInfo2();
	printHex(retornoDQ());
	printHex(retornoDD());
	printHex(retornoDW());
	printHex(retornoDB());
	printHex(dd(retornoDQ()));
	printHex(dw(retornoDQ()));
	printHex(db(retornoDQ()));

	ptr stringMem = db<200>;
	memset(stringMem, 200, 0);
	read(stringMem, 200);
	reverseString(stringMem);
	print(stringMem);


	// cannot be called inside defer cause its another func
	dq rbpVar;
	loadVar(rbpVar, rbp);
	ptr args<dq> = getArgsPtr(rbpVar);

	for dq i = 0; i < argc; i++; {
		print("arg ");
		print(args[i]);
		print("\n");
	}

	testThreadsCARALHOS();

	//needs "nc -lvnp 8080" running to connect
	testTCP_lib();

	nanosleep(1,0);
	clock_gettimeExec();
	exit(69);

    return;
}
